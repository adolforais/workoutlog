<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Adolfo's Performance Analysis</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 15px;
      background-color: white; /* fallback */
      background-image: url('background.jpg');
      background-repeat: no-repeat;
      background-size: cover;
      background-position: center center;
    }

    #mainContent {
      background-color: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 18px;
      color: black;
      max-width: 700px;
      margin: auto;
      box-shadow: 0 0 12px 2px #e3bc60;
    }

    h1 {
      color: #4a7d23;
      margin-bottom: 18px;
    }

    /* --- Collapsible Groups --- */
    .group-container {
      border: 1px solid #bbb;
      margin-bottom: 12px;
      border-radius: 6px;
      overflow: hidden;
      background-color: #f9f9f9;
    }

    .group-header {
      background-color: #e0e0e0;
      padding: 10px 15px;
      cursor: pointer;
      user-select: none;
      font-weight: bold;
      font-size: 1.1em;
      color: black;
    }
    
    .group-header:hover {
        background-color: #d0d0d0;
    }

    .group-content {
      display: none; /* Initially collapsed */
      padding: 15px;
      background-color: #fff;
    }

    .analysis-card {
      border: 1px solid #ccc;
      border-left: 5px solid #4a7d23;
      border-radius: 6px;
      margin-bottom: 15px;
      padding: 12px;
      background-color: #fdfdfd;
    }
    
    .analysis-card:last-child { margin-bottom: 0; }
    
    .analysis-card h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #333;
    }

    .analysis-card p {
      margin: 5px 0;
      line-height: 1.4;
    }
    
    .analysis-card strong { color: #3b2a87; }

    .history-table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    .history-table th, .history-table td { border: 1px solid #ddd; padding: 6px 8px; font-size: 0.95em; }
    .history-table th { background-color: #f5f5f5; text-align: left; }

    .recommendation {
      font-weight: bold;
      font-style: italic;
      display: block;
      margin-top: 10px;
      padding: 8px;
      border-radius: 4px;
    }

    .rec-reduce { color: #d0021b; background-color: #fdeaea; }
    .rec-increase { color: #a06c00; background-color: #fff8e1; }
    .rec-maintain { color: #3b2a87; background-color: #f0f3ff; }
    .rec-deload { color: #005a9c; background-color: #eaf6ff; }
  </style>
  <script src="workout_program.js"></script>
</head>
<body>
  <div id="mainContent">
    <h1>Full Performance Analysis</h1>
    <div id="analysisReport"></div>
  </div>

  <script>
    // Collapsing groups
    function toggleGroup(contentId) {
      const el = document.getElementById(contentId);
      el.style.display = (el.style.display === 'block') ? 'none' : 'block';
    }

    document.addEventListener('DOMContentLoaded', function () {
      const rirTargets = ["2-3", "2", "1", "3-4"];

      // Classify exercise for deload rules
      function classifyExercise(name) {
        const n = String(name || '').toLowerCase();
        if (n.includes('deadlift')) return 'deadlift';
        const compoundKeys = [
          'squat','bench','press','row','pull-up','pull up','pullup',
          'chin-up','chin up','dip','lunge','rdl','hip thrust','good morning',
          'clean','snatch','front squat','overhead press','ohp'
        ];
        for (const k of compoundKeys) {
          if (n.includes(k)) return 'compound';
        }
        return 'isolation';
      }

      function roundToStep(x, step) {
        const s = step || 0.5;
        return Math.round((x || 0) / s) * s;
      }

      function collectExerciseSessions(exerciseName, allLogs) {
        const out = [];
        for (let i = 0; i < allLogs.length; i++) {
          const entry = allLogs[i];
          const foundEx = entry.log && entry.log.find(l => l.name === exerciseName);
          if (!foundEx) continue;
          out.push({
            index: i,
            date: entry.date,
            week: parseInt(entry.week),
            weight: parseFloat(foundEx.weight),
            reps: (foundEx.reps || []).map(r => parseInt(r))
          });
        }
        return out; // chronological order, earliest to latest
      }

      function findBaselineSession(exerciseName, allLogs) {
        // Find the most recent HEAVY week for this exercise, prefer Week 3, else 2, else 1
        const preferredWeeks = [3, 2, 1];
        for (let i = allLogs.length - 1; i >= 0; i--) {
          const entry = allLogs[i];
          const foundEx = entry.log && entry.log.find(l => l.name === exerciseName);
          if (!foundEx) continue;
          const w = parseInt(entry.week);
          if (preferredWeeks.includes(w)) {
            return {
              date: entry.date,
              week: w,
              weight: parseFloat(foundEx.weight),
              reps: foundEx.reps.map(r => parseInt(r))
            };
          }
        }
        return null;
      }

      function getHistoryForDisplay(exerciseName, allLogs, lastSession, nextWeek) {
        const sessions = collectExerciseSessions(exerciseName, allLogs);
        if (sessions.length === 0) return [];

        // Find the entry that matches lastSession by index and week
        const lastIdx = sessions.findIndex(s => s.week === lastSession.week && s.date === lastSession.date && s.weight === lastSession.weight);

        // When we are inside Weeks 1-3, show from Week 1 up to current week
        if (lastSession.week >= 1 && lastSession.week <= 3) {
          const currentCycle = sessions.filter(s => s.week >= 1 && s.week <= lastSession.week).slice(-lastSession.week);
          return currentCycle.filter(s => s.week >= 1 && s.week <= lastSession.week);
        }

        // If we just finished Week 3 and next is Week 4, show Weeks 1-3 of the current cycle
        if (lastSession.week === 3 && nextWeek === 4) {
          const currentCycle = sessions.filter(s => s.week >= 1 && s.week <= 3).slice(-3);
          return currentCycle;
        }

        // If we are at Week 4 and next is Week 1, show Weeks 1-3 from the previous cycle
        if (lastSession.week === 4 && nextWeek === 1) {
          // Walk backwards from the last Week 4 entry to collect a preceding 3-2-1 sequence
          // sessions is chronological, so find the last occurrence of Week 4
          let lastW4 = -1;
          for (let i = sessions.length - 1; i >= 0; i--) {
            if (sessions[i].week === 4) { lastW4 = i; break; }
          }
          if (lastW4 === -1) return [];
          const prev = [];
          let expect = 3;
          for (let i = lastW4 - 1; i >= 0 && expect >= 1; i--) {
            if (sessions[i].week === expect) {
              prev.push(sessions[i]);
              expect -= 1;
            } else if (sessions[i].week === 4) {
              // Hit an earlier cycle boundary without finding 3-2-1 in order
              break;
            }
          }
          prev.reverse(); // order as 1,2,3
          return prev;
        }

        return [];
      }

      // Returns [lowKg, highKg, noteText]
      function deloadRangeFor(exName, lastWeight) {
        const type = classifyExercise(exName);
        let lowPct, highPct, note;
        if (type === 'deadlift') {
          lowPct = 0.85; highPct = 0.90; note = '10 to 15 percent lighter';
        } else if (type === 'compound') {
          lowPct = 0.90; highPct = 0.95; note = '5 to 10 percent lighter';
        } else {
          lowPct = 0.95; highPct = 1.00; note = '0 to 5 percent lighter';
        }
        const low = roundToStep(lastWeight * lowPct, 0.5);
        const high = roundToStep(lastWeight * highPct, 0.5);
        return [low, high, note, type];
      }

      function getAnalysisForExerciseHTML(exerciseName, allLogs) {
        const exDetails = (Object.values(program).flat()).find(e => e.name === exerciseName);
        if (!exDetails) return '';

        // Find the most recent logged session for this exercise
        let lastSession = null;
        for (let i = allLogs.length - 1; i >= 0; i--) {
          const foundEx = allLogs[i].log.find(l => l.name === exerciseName);
          if (foundEx) {
            lastSession = {
              date: allLogs[i].date,
              week: parseInt(allLogs[i].week),
              weight: parseFloat(foundEx.weight),
              reps: foundEx.reps.map(r => parseInt(r))
            };
            break;
          }
        }
        if (!lastSession) return '';

        const weekIdx = lastSession.week - 1;
        const targetRepsStr = exDetails.reps[weekIdx];
        const targetSets = exDetails.sets[weekIdx];
        let recommendationHTML = '';
        const nextWeek = lastSession.week >= 4 ? 1 : lastSession.week + 1;

        const history = getHistoryForDisplay(exerciseName, allLogs, lastSession, nextWeek);
        let historyHTML = '';
        if (history.length > 0) {
          historyHTML += '<table class="history-table"><thead><tr><th>Week</th><th>Weight (kg)</th><th>Reps</th></tr></thead><tbody>';
          history.forEach(s => {
            historyHTML += `<tr><td>${s.week}</td><td>${s.weight.toFixed(1)}</td><td>${(s.reps || []).join(', ')}</td></tr>`;
          });
          historyHTML += '</tbody></table>';
        }

        if (nextWeek === 4 && lastSession.week === 3) {
          // Deload rules only when moving from Week 3 to Week 4
          const [lowKg, highKg, note, type] = deloadRangeFor(exerciseName, lastSession.weight);
          let extra = '';
          const n2 = exerciseName.toLowerCase();
          if (n2.includes('pull-up') || n2.includes('pull up') || n2.includes('pullup') || n2.includes('chin')) {
            extra = '';
          }
          recommendationHTML = `<span class="recommendation rec-deload">
            ACTION: DELOAD WEEK. Use about ${lowKg.toFixed(1)} to ${highKg.toFixed(1)} kg (${note}).
            Do the low end of the rep range at RIR 3 to 4, and focus on perfect form.
            ${extra}
          </span>`;
        } else if (lastSession.week === 4 && nextWeek === 1) {
          // New cycle start, base on the last heavy week, not the deload
          const baseline = findBaselineSession(exerciseName, allLogs) || lastSession;
          const repRangeParts = String(exDetails.reps[(baseline.week - 1)]).split('-');
          const minOfRepRange = parseInt(repRangeParts[0]);
          const topOfRepRange = parseInt(repRangeParts.pop());
          const failedToMeetMinimum = baseline.reps.some(r => r < minOfRepRange);
          const achievedTopReps = baseline.reps.length > 0 && baseline.reps.every(r => r >= topOfRepRange);

          if (failedToMeetMinimum) {
            const newWeight = (baseline.weight * 0.9).toFixed(1);
            recommendationHTML = `<span class="recommendation rec-reduce">ACTION: New cycle, Week 1. Start around ${newWeight} kg. Reset slightly and build back up.</span>`;
          } else if (achievedTopReps) {
            const newWeight = (baseline.weight + 2.5).toFixed(1);
            recommendationHTML = `<span class="recommendation rec-increase">ACTION: New cycle, Week 1. Nudge up to about ${newWeight} kg. Keep RIR 2 to 3.</span>`;
          } else {
            const newWeight = baseline.weight.toFixed(1);
            recommendationHTML = `<span class="recommendation rec-maintain">ACTION: New cycle, Week 1. Start about ${newWeight} kg. Keep RIR 2 to 3 and aim to beat your Week ${baseline.week} reps.</span>`;
          }
        } else {
          // Normal progression within the cycle
          const repRangeParts = String(targetRepsStr).split('-');
          const minOfRepRange = parseInt(repRangeParts[0]);
          const topOfRepRange = parseInt(repRangeParts.pop());
          const failedToMeetMinimum = lastSession.reps.some(r => r < minOfRepRange);
          const achievedTopReps = lastSession.reps.length > 0 && lastSession.reps.every(r => r >= topOfRepRange);

          if (failedToMeetMinimum) {
            const newWeight = (lastSession.weight * 0.9).toFixed(1);
            recommendationHTML = `<span class="recommendation rec-reduce">ACTION: Reduce weight. You fell below the target rep range. Try about ${newWeight} kg next time.</span>`;
          } else if (achievedTopReps) {
            const newWeight = (lastSession.weight + 2.5).toFixed(1);
            recommendationHTML = `<span class="recommendation rec-increase">ACTION: Increase weight. You hit the top of the rep range. Try about ${newWeight} kg.</span>`;
          } else {
            recommendationHTML = `<span class="recommendation rec-maintain">ACTION: Keep weight the same. Your goal is to beat ${lastSession.reps.join(', ')} reps.</span>`;
          }
        }

        return `
          <div class="analysis-card">
            <h3>${exerciseName}</h3>
            <p><strong>Last Session Week ${lastSession.week}:</strong> ${lastSession.weight} kg for <strong>${lastSession.reps.join(', ')}</strong> reps.</p>
            <p><em>Program target was: ${targetSets} sets of ${targetRepsStr} reps at RIR ${rirTargets[weekIdx]}</em></p>
            ${historyHTML}
            ${recommendationHTML}
          </div>
        `;
      }

      function generateFullReport() {
        const reportDiv = document.getElementById('analysisReport');
        const allLogs = JSON.parse(localStorage.getItem('hypertrophyLogs') || '[]');

        if (allLogs.length === 0) {
          reportDiv.innerHTML = '<p><i>No logs found. Go to the main page and save a session first.</i></p>';
          return;
        }

        // Map exercise to day key
        const exerciseToDayMap = new Map();
        for (const dayKey in program) {
          program[dayKey].forEach(ex => {
            exerciseToDayMap.set(ex.name, dayKey);
          });
        }

        // Group logged exercises by workout day
        const groupedExercises = {};
        allLogs.forEach(session => {
          session.log.forEach(exercise => {
            const dayKey = exerciseToDayMap.get(exercise.name);
            if (dayKey) {
              if (!groupedExercises[dayKey]) groupedExercises[dayKey] = new Set();
              groupedExercises[dayKey].add(exercise.name);
            }
          });
        });
        
        let fullReportHTML = '';
        
        // Maintain program day order
        for (const dayKey of Object.keys(programDays)) {
          const exercisesForDay = groupedExercises[dayKey];
          if (!exercisesForDay || exercisesForDay.size === 0) continue;

          const contentId = `groupContent_${dayKey}`;
          fullReportHTML += `
            <div class="group-container">
              <div class="group-header" onclick="toggleGroup('${contentId}')">
                ${programDays[dayKey]}
              </div>
              <div class="group-content" id="${contentId}">
          `;

          const orderedExercises = program[dayKey]
            .map(ex => ex.name)
            .filter(exName => exercisesForDay.has(exName));

          orderedExercises.forEach(exName => {
            fullReportHTML += getAnalysisForExerciseHTML(exName, allLogs);
          });

          fullReportHTML += `
              </div>
            </div>
          `;
        }
        
        reportDiv.innerHTML = fullReportHTML;
      }
      
      generateFullReport();
    });
  </script>
</body>
</html>
